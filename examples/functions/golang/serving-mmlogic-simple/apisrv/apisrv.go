/*
package apisrv is a basic gRPC serving harness from which you can serve an MMF.
The gRPC service is defined in [REPO_ROOT]/api/protobuf-spec/function.proto
Most of the documentation for what these calls should do is in that file!

Copyright 2018 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

package apisrv

import (
	"context"
	"net"

	log "github.com/sirupsen/logrus"

	"github.com/GoogleCloudPlatform/open-match/internal/mmf"
	api "github.com/GoogleCloudPlatform/open-match/internal/pb"
	"github.com/gomodule/redigo/redis"
	"github.com/spf13/viper"

	"go.opencensus.io/plugin/ocgrpc"
	"google.golang.org/grpc"
)

// Logrus structured logging setup
var (
	fnLogFields = log.Fields{
		"app":       "openmatch",
		"component": "function_service",
	}
	fnLog = log.WithFields(fnLogFields)
)

// FunctionServer implements api.FunctionServer, the server generated by compiling
// the protobuf, by fulfilling the api.FunctionServer interface.
type FunctionServer struct {
	grpc    *grpc.Server
	cfg     *viper.Viper
	pool    *redis.Pool
	mmlogic api.MmLogicClient
}
type functionServer FunctionServer

// New returns an instantiated service
func New(cfg *viper.Viper, pool *redis.Pool, client api.MmLogicClient) *FunctionServer {

	/*
		// Attempt to connect to MMLogic API. Assumes that this FunctionServer is
		// running in the same k8s namespace as the MMLogic Service. Since MMLogic
		// API is optional, all this code must execute successfully and log
		// warnings if the MMLogic API is not running.
		ip := os.Getenv("OM_MMLOGICAPI_SERVICE_HOST")
		if len(ip) == 0 {
			log.Warning("Couldn't get IP for MMLogic API from environment! Have you started the MMLogic API yet?")
		} else {
			port := os.Getenv("OM_MMLOGICAPI_SERVICE_PORT")
			if len(port) == 0 {
				log.Warning("Couldn't get port for MMLogic API from environment! Have you started the MMLogic API yet?")
			} else {

				//Connect
				conn, err := grpc.Dial(fmt.Sprintf("%v:%v", ip, port), grpc.WithInsecure())
				if err != nil {
					log.Warning("failed to connect: %s", err.Error())
				} else {
					//func(t time.Time) *time.Time { return &t }(time.Now())
					client = api.NewMmLogicClient(conn)
				}
			}
		}
	*/

	// Initialize the server state
	s := FunctionServer{
		pool:    pool,
		grpc:    grpc.NewServer(grpc.StatsHandler(&ocgrpc.ServerHandler{})),
		cfg:     cfg,
		mmlogic: client,
	}

	// Register gRPC server
	api.RegisterFunctionServer(s.grpc, (*functionServer)(&s))
	fnLog.Info("Successfully registered gRPC server")
	return &s
}

// Open starts the api grpc service listening on the configured port.
func (s *FunctionServer) Open() error {
	ln, err := net.Listen("tcp", ":"+s.cfg.GetString("api.functions.port"))
	if err != nil {
		fnLog.WithFields(log.Fields{
			"error": err.Error(),
			"port":  s.cfg.GetInt("api.functions.port"),
		}).Error("net.Listen() error")
		return err
	}
	fnLog.WithFields(log.Fields{"port": s.cfg.GetInt("api.functions.port")}).Info("TCP net listener initialized")

	go func() {
		err := s.grpc.Serve(ln)
		if err != nil {
			fnLog.WithFields(log.Fields{"error": err.Error()}).Error("gRPC serve() error")
		}
		fnLog.Info("serving gRPC endpoints")
	}()

	return nil
}

// Run is this service's implementation of the gRPC call defined in
// api/protobuf-spec/function.proto
func (s *functionServer) Run(c context.Context, fnArgs *api.Arguments) (*api.Result, error) {
	// Everything the mmf needs to know about its specific
	// run (where to look in state storage for its profile, where to write
	// its results to state storage) needs to be in the fnArgs message.
	err := mmf.Run(fnArgs, s.cfg, s.mmlogic)
	if err != nil {
		fnLog.WithFields(log.Fields{"error": err.Error()}).Error("function.Run error")
		return &api.Result{Success: false, Error: err.Error()}, err
	}
	return &api.Result{Success: true}, nil
}
