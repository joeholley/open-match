// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api/protobuf-spec/messages.proto

package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type MmfSpec_Type int32

const (
	// Generic serving types.
	MmfSpec_GRPC MmfSpec_Type = 0
	MmfSpec_REST MmfSpec_Type = 1
	// Deprecated types
	MmfSpec_K8SJOB MmfSpec_Type = 7
)

var MmfSpec_Type_name = map[int32]string{
	0: "GRPC",
	1: "REST",
	7: "K8SJOB",
}
var MmfSpec_Type_value = map[string]int32{
	"GRPC":   0,
	"REST":   1,
	"K8SJOB": 7,
}

func (x MmfSpec_Type) String() string {
	return proto.EnumName(MmfSpec_Type_name, int32(x))
}
func (MmfSpec_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor4, []int{1, 0} }

// Open Match's internal representation and wire protocol format for "MatchObjects".
// In order to request a match using the Backend API, your backend code should generate
// a new MatchObject with an ID and properties filled in (for more details about valid
// values for these fields, see the documentation).  Open Match then sends the Match
// Object through to your matchmaking function, where you add players to 'rosters' and
// store any schemaless data you wish in the 'properties' field.  The MatchObject
// is then sent, populated, out through the Backend API to your backend code.
//
// MatchObjects contain a number of fields, but many gRPC calls that take a
// MatchObject as input only require a few of them to be filled in.  Check the
// gRPC function in question for more details.
type MatchObject struct {
	Id         string        `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Properties string        `protobuf:"bytes,2,opt,name=properties" json:"properties,omitempty"`
	Error      string        `protobuf:"bytes,3,opt,name=error" json:"error,omitempty"`
	Rosters    []*Roster     `protobuf:"bytes,4,rep,name=rosters" json:"rosters,omitempty"`
	Pools      []*PlayerPool `protobuf:"bytes,5,rep,name=pools" json:"pools,omitempty"`
	Status     string        `protobuf:"bytes,6,opt,name=status" json:"status,omitempty"`
	Name       string        `protobuf:"bytes,7,opt,name=name" json:"name,omitempty"`
}

func (m *MatchObject) Reset()                    { *m = MatchObject{} }
func (m *MatchObject) String() string            { return proto.CompactTextString(m) }
func (*MatchObject) ProtoMessage()               {}
func (*MatchObject) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{0} }

func (m *MatchObject) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *MatchObject) GetProperties() string {
	if m != nil {
		return m.Properties
	}
	return ""
}

func (m *MatchObject) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *MatchObject) GetRosters() []*Roster {
	if m != nil {
		return m.Rosters
	}
	return nil
}

func (m *MatchObject) GetPools() []*PlayerPool {
	if m != nil {
		return m.Pools
	}
	return nil
}

func (m *MatchObject) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *MatchObject) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type MmfSpec struct {
	Name string       `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Host string       `protobuf:"bytes,2,opt,name=host" json:"host,omitempty"`
	Port int32        `protobuf:"varint,3,opt,name=port" json:"port,omitempty"`
	Type MmfSpec_Type `protobuf:"varint,4,opt,name=type,enum=messages.MmfSpec_Type" json:"type,omitempty"`
}

func (m *MmfSpec) Reset()                    { *m = MmfSpec{} }
func (m *MmfSpec) String() string            { return proto.CompactTextString(m) }
func (*MmfSpec) ProtoMessage()               {}
func (*MmfSpec) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{1} }

func (m *MmfSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MmfSpec) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *MmfSpec) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *MmfSpec) GetType() MmfSpec_Type {
	if m != nil {
		return m.Type
	}
	return MmfSpec_GRPC
}

type CreateMatchRequest struct {
	Matchobject *MatchObject `protobuf:"bytes,1,opt,name=matchobject" json:"matchobject,omitempty"`
	Mmfspec     *MmfSpec     `protobuf:"bytes,2,opt,name=mmfspec" json:"mmfspec,omitempty"`
}

func (m *CreateMatchRequest) Reset()                    { *m = CreateMatchRequest{} }
func (m *CreateMatchRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateMatchRequest) ProtoMessage()               {}
func (*CreateMatchRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{2} }

func (m *CreateMatchRequest) GetMatchobject() *MatchObject {
	if m != nil {
		return m.Matchobject
	}
	return nil
}

func (m *CreateMatchRequest) GetMmfspec() *MmfSpec {
	if m != nil {
		return m.Mmfspec
	}
	return nil
}

type ListMatchesRequest struct {
	Matchobject *MatchObject `protobuf:"bytes,1,opt,name=matchobject" json:"matchobject,omitempty"`
	Mmfspec     *MmfSpec     `protobuf:"bytes,2,opt,name=mmfspec" json:"mmfspec,omitempty"`
}

func (m *ListMatchesRequest) Reset()                    { *m = ListMatchesRequest{} }
func (m *ListMatchesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListMatchesRequest) ProtoMessage()               {}
func (*ListMatchesRequest) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{3} }

func (m *ListMatchesRequest) GetMatchobject() *MatchObject {
	if m != nil {
		return m.Matchobject
	}
	return nil
}

func (m *ListMatchesRequest) GetMmfspec() *MmfSpec {
	if m != nil {
		return m.Mmfspec
	}
	return nil
}

// Data structure to hold a list of players in a match.
type Roster struct {
	Name    string    `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Players []*Player `protobuf:"bytes,2,rep,name=players" json:"players,omitempty"`
}

func (m *Roster) Reset()                    { *m = Roster{} }
func (m *Roster) String() string            { return proto.CompactTextString(m) }
func (*Roster) ProtoMessage()               {}
func (*Roster) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{4} }

func (m *Roster) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Roster) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

// A 'hard' filter to apply to the player pool.
type Filter struct {
	Name      string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Attribute string `protobuf:"bytes,2,opt,name=attribute" json:"attribute,omitempty"`
	Maxv      int64  `protobuf:"varint,3,opt,name=maxv" json:"maxv,omitempty"`
	Minv      int64  `protobuf:"varint,4,opt,name=minv" json:"minv,omitempty"`
	Stats     *Stats `protobuf:"bytes,5,opt,name=stats" json:"stats,omitempty"`
}

func (m *Filter) Reset()                    { *m = Filter{} }
func (m *Filter) String() string            { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()               {}
func (*Filter) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{5} }

func (m *Filter) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Filter) GetAttribute() string {
	if m != nil {
		return m.Attribute
	}
	return ""
}

func (m *Filter) GetMaxv() int64 {
	if m != nil {
		return m.Maxv
	}
	return 0
}

func (m *Filter) GetMinv() int64 {
	if m != nil {
		return m.Minv
	}
	return 0
}

func (m *Filter) GetStats() *Stats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// Holds statistics
type Stats struct {
	Count   int64   `protobuf:"varint,1,opt,name=count" json:"count,omitempty"`
	Elapsed float64 `protobuf:"fixed64,2,opt,name=elapsed" json:"elapsed,omitempty"`
}

func (m *Stats) Reset()                    { *m = Stats{} }
func (m *Stats) String() string            { return proto.CompactTextString(m) }
func (*Stats) ProtoMessage()               {}
func (*Stats) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{6} }

func (m *Stats) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Stats) GetElapsed() float64 {
	if m != nil {
		return m.Elapsed
	}
	return 0
}

// PlayerPools are defined by a set of 'hard' filters, and can be filled in
// with the players that match those filters.
//
// PlayerPools contain a number of fields, but many gRPC calls that take a
// PlayerPool as input only require a few of them to be filled in.  Check the
// gRPC function in question for more details.
type PlayerPool struct {
	Name    string    `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Filters []*Filter `protobuf:"bytes,2,rep,name=filters" json:"filters,omitempty"`
	Roster  *Roster   `protobuf:"bytes,3,opt,name=roster" json:"roster,omitempty"`
	Stats   *Stats    `protobuf:"bytes,4,opt,name=stats" json:"stats,omitempty"`
}

func (m *PlayerPool) Reset()                    { *m = PlayerPool{} }
func (m *PlayerPool) String() string            { return proto.CompactTextString(m) }
func (*PlayerPool) ProtoMessage()               {}
func (*PlayerPool) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{7} }

func (m *PlayerPool) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PlayerPool) GetFilters() []*Filter {
	if m != nil {
		return m.Filters
	}
	return nil
}

func (m *PlayerPool) GetRoster() *Roster {
	if m != nil {
		return m.Roster
	}
	return nil
}

func (m *PlayerPool) GetStats() *Stats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// Open Match's internal representation and wire protocol format for "Players".
// In order to enter matchmaking using the Frontend API, your client code should generate
// a consistent (same result for each client every time they launch) with an ID and
// properties filled in (for more details about valid values for these fields,
// see the documentation).
// Players contain a number of fields, but the gRPC calls that take a
// Player as input only require a few of them to be filled in.  Check the
// gRPC function in question for more details.
type Player struct {
	Id         string              `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Properties string              `protobuf:"bytes,2,opt,name=properties" json:"properties,omitempty"`
	Pool       string              `protobuf:"bytes,3,opt,name=pool" json:"pool,omitempty"`
	Attributes []*Player_Attribute `protobuf:"bytes,4,rep,name=attributes" json:"attributes,omitempty"`
	Assignment string              `protobuf:"bytes,5,opt,name=assignment" json:"assignment,omitempty"`
	Status     string              `protobuf:"bytes,6,opt,name=status" json:"status,omitempty"`
	Error      string              `protobuf:"bytes,7,opt,name=error" json:"error,omitempty"`
}

func (m *Player) Reset()                    { *m = Player{} }
func (m *Player) String() string            { return proto.CompactTextString(m) }
func (*Player) ProtoMessage()               {}
func (*Player) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{8} }

func (m *Player) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Player) GetProperties() string {
	if m != nil {
		return m.Properties
	}
	return ""
}

func (m *Player) GetPool() string {
	if m != nil {
		return m.Pool
	}
	return ""
}

func (m *Player) GetAttributes() []*Player_Attribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

func (m *Player) GetAssignment() string {
	if m != nil {
		return m.Assignment
	}
	return ""
}

func (m *Player) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Player) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type Player_Attribute struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value int64  `protobuf:"varint,2,opt,name=value" json:"value,omitempty"`
}

func (m *Player_Attribute) Reset()                    { *m = Player_Attribute{} }
func (m *Player_Attribute) String() string            { return proto.CompactTextString(m) }
func (*Player_Attribute) ProtoMessage()               {}
func (*Player_Attribute) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{8, 0} }

func (m *Player_Attribute) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Player_Attribute) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// Simple message to return success/failure and error status.
type Result struct {
	Success bool   `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
	Error   string `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
}

func (m *Result) Reset()                    { *m = Result{} }
func (m *Result) String() string            { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()               {}
func (*Result) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{9} }

func (m *Result) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *Result) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// IlInput is an empty message reserved for future use.
type IlInput struct {
}

func (m *IlInput) Reset()                    { *m = IlInput{} }
func (m *IlInput) String() string            { return proto.CompactTextString(m) }
func (*IlInput) ProtoMessage()               {}
func (*IlInput) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{10} }

type Assignments struct {
	Rosters    []*Roster `protobuf:"bytes,1,rep,name=rosters" json:"rosters,omitempty"`
	Assignment string    `protobuf:"bytes,10,opt,name=assignment" json:"assignment,omitempty"`
}

func (m *Assignments) Reset()                    { *m = Assignments{} }
func (m *Assignments) String() string            { return proto.CompactTextString(m) }
func (*Assignments) ProtoMessage()               {}
func (*Assignments) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{11} }

func (m *Assignments) GetRosters() []*Roster {
	if m != nil {
		return m.Rosters
	}
	return nil
}

func (m *Assignments) GetAssignment() string {
	if m != nil {
		return m.Assignment
	}
	return ""
}

// The message for passing in the per-request identifiers
// to a matchmaking function; used so it knows which records to
// write/update in state storage.  Internal to Open Match; this is populated by
// the Backend API and sent to your gRPC-served MMF.
type Request struct {
	ProfileId  string `protobuf:"bytes,1,opt,name=profile_id,json=profileId" json:"profile_id,omitempty"`
	RequestId  string `protobuf:"bytes,2,opt,name=request_id,json=requestId" json:"request_id,omitempty"`
	ProposalId string `protobuf:"bytes,3,opt,name=proposal_id,json=proposalId" json:"proposal_id,omitempty"`
	ResultId   string `protobuf:"bytes,4,opt,name=result_id,json=resultId" json:"result_id,omitempty"`
	Timestamp  int64  `protobuf:"varint,5,opt,name=timestamp" json:"timestamp,omitempty"`
}

func (m *Request) Reset()                    { *m = Request{} }
func (m *Request) String() string            { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()               {}
func (*Request) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{12} }

func (m *Request) GetProfileId() string {
	if m != nil {
		return m.ProfileId
	}
	return ""
}

func (m *Request) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *Request) GetProposalId() string {
	if m != nil {
		return m.ProposalId
	}
	return ""
}

func (m *Request) GetResultId() string {
	if m != nil {
		return m.ResultId
	}
	return ""
}

func (m *Request) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

// The message for passing all the necessary arguments to a
// matchmaking function.
type Arguments struct {
	Request     *Request     `protobuf:"bytes,1,opt,name=request" json:"request,omitempty"`
	Matchobject *MatchObject `protobuf:"bytes,2,opt,name=matchobject" json:"matchobject,omitempty"`
}

func (m *Arguments) Reset()                    { *m = Arguments{} }
func (m *Arguments) String() string            { return proto.CompactTextString(m) }
func (*Arguments) ProtoMessage()               {}
func (*Arguments) Descriptor() ([]byte, []int) { return fileDescriptor4, []int{13} }

func (m *Arguments) GetRequest() *Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *Arguments) GetMatchobject() *MatchObject {
	if m != nil {
		return m.Matchobject
	}
	return nil
}

func init() {
	proto.RegisterType((*MatchObject)(nil), "messages.MatchObject")
	proto.RegisterType((*MmfSpec)(nil), "messages.MmfSpec")
	proto.RegisterType((*CreateMatchRequest)(nil), "messages.CreateMatchRequest")
	proto.RegisterType((*ListMatchesRequest)(nil), "messages.ListMatchesRequest")
	proto.RegisterType((*Roster)(nil), "messages.Roster")
	proto.RegisterType((*Filter)(nil), "messages.Filter")
	proto.RegisterType((*Stats)(nil), "messages.Stats")
	proto.RegisterType((*PlayerPool)(nil), "messages.PlayerPool")
	proto.RegisterType((*Player)(nil), "messages.Player")
	proto.RegisterType((*Player_Attribute)(nil), "messages.Player.Attribute")
	proto.RegisterType((*Result)(nil), "messages.Result")
	proto.RegisterType((*IlInput)(nil), "messages.IlInput")
	proto.RegisterType((*Assignments)(nil), "messages.Assignments")
	proto.RegisterType((*Request)(nil), "messages.Request")
	proto.RegisterType((*Arguments)(nil), "messages.Arguments")
	proto.RegisterEnum("messages.MmfSpec_Type", MmfSpec_Type_name, MmfSpec_Type_value)
}

func init() { proto.RegisterFile("api/protobuf-spec/messages.proto", fileDescriptor4) }

var fileDescriptor4 = []byte{
	// 797 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x55, 0xcd, 0x8e, 0xe3, 0x44,
	0x10, 0xc6, 0x89, 0x63, 0xc7, 0x15, 0x69, 0x09, 0xad, 0x61, 0x65, 0x2d, 0x7f, 0x91, 0x25, 0x50,
	0x94, 0xd5, 0x26, 0x52, 0xd0, 0x6a, 0x56, 0xdc, 0xb2, 0x23, 0x58, 0x02, 0xac, 0x36, 0xea, 0xec,
	0x05, 0x2e, 0xa8, 0x63, 0x77, 0x32, 0x46, 0xb6, 0xbb, 0xb7, 0xbb, 0x1d, 0x31, 0xbc, 0x01, 0x07,
	0x1e, 0x80, 0x03, 0x27, 0x1e, 0x8a, 0xd7, 0x41, 0x5d, 0xb6, 0x63, 0x93, 0x99, 0xe1, 0xe7, 0xc2,
	0xad, 0xeb, 0xab, 0x2f, 0xae, 0x9f, 0xaf, 0xaa, 0x02, 0x13, 0x26, 0xd3, 0x85, 0x54, 0xc2, 0x88,
	0x5d, 0xb9, 0x7f, 0xa2, 0x25, 0x8f, 0x17, 0x39, 0xd7, 0x9a, 0x1d, 0xb8, 0x9e, 0x23, 0x4c, 0x86,
	0x8d, 0x1d, 0xfd, 0xe1, 0xc0, 0xe8, 0x25, 0x33, 0xf1, 0xf5, 0xab, 0xdd, 0x0f, 0x3c, 0x36, 0xe4,
	0x01, 0xf4, 0xd2, 0x24, 0x74, 0x26, 0xce, 0x34, 0xa0, 0xbd, 0x34, 0x21, 0x1f, 0x02, 0x48, 0x25,
	0x24, 0x57, 0x26, 0xe5, 0x3a, 0xec, 0x21, 0xde, 0x41, 0xc8, 0x05, 0x0c, 0xb8, 0x52, 0x42, 0x85,
	0x7d, 0x74, 0x55, 0x06, 0x99, 0x81, 0xaf, 0x84, 0x36, 0x5c, 0xe9, 0xd0, 0x9d, 0xf4, 0xa7, 0xa3,
	0xe5, 0x78, 0x7e, 0xca, 0x80, 0xa2, 0x83, 0x36, 0x04, 0x32, 0x83, 0x81, 0x14, 0x22, 0xd3, 0xe1,
	0x00, 0x99, 0x17, 0x2d, 0x73, 0x93, 0xb1, 0x1b, 0xae, 0x36, 0x42, 0x64, 0xb4, 0xa2, 0x90, 0x87,
	0xe0, 0x69, 0xc3, 0x4c, 0xa9, 0x43, 0x0f, 0xc3, 0xd5, 0x16, 0x21, 0xe0, 0x16, 0x2c, 0xe7, 0xa1,
	0x8f, 0x28, 0xbe, 0xa3, 0x5f, 0x1d, 0xf0, 0x5f, 0xe6, 0xfb, 0xad, 0xe4, 0xf1, 0xc9, 0xef, 0xb4,
	0x7e, 0x8b, 0x5d, 0x0b, 0x6d, 0xea, 0x9a, 0xf0, 0x6d, 0x31, 0x29, 0x94, 0xc1, 0x62, 0x06, 0x14,
	0xdf, 0x64, 0x06, 0xae, 0xb9, 0x91, 0x3c, 0x74, 0x27, 0xce, 0xf4, 0xc1, 0xf2, 0x61, 0x9b, 0x5e,
	0xfd, 0xf1, 0xf9, 0xeb, 0x1b, 0xc9, 0x29, 0x72, 0xa2, 0x4f, 0xc0, 0xb5, 0x16, 0x19, 0x82, 0xfb,
	0x82, 0x6e, 0xae, 0xc6, 0x6f, 0xd9, 0x17, 0xfd, 0x7c, 0xfb, 0x7a, 0xec, 0x10, 0x00, 0xef, 0xeb,
	0x67, 0xdb, 0xaf, 0x5e, 0x3d, 0x1f, 0xfb, 0xd1, 0x4f, 0x40, 0xae, 0x14, 0x67, 0x86, 0x63, 0xeb,
	0x29, 0x7f, 0x53, 0x72, 0x6d, 0xc8, 0x25, 0x8c, 0x72, 0x6b, 0x0b, 0x94, 0x02, 0x93, 0x1d, 0x2d,
	0xdf, 0xed, 0x04, 0x6c, 0x75, 0xa2, 0x5d, 0x26, 0x79, 0x0c, 0x7e, 0x9e, 0xef, 0xad, 0xd0, 0x58,
	0xcd, 0x68, 0xf9, 0xce, 0xad, 0x2c, 0x69, 0xc3, 0xb0, 0xb1, 0xbf, 0x49, 0xb5, 0xc1, 0x8f, 0x71,
	0xfd, 0xff, 0xc6, 0xfe, 0x12, 0xbc, 0x4a, 0xfe, 0x3b, 0x15, 0x99, 0x81, 0x2f, 0x51, 0x72, 0x3b,
	0x68, 0x67, 0x53, 0x53, 0xcd, 0x02, 0x6d, 0x08, 0xd1, 0xcf, 0x0e, 0x78, 0x5f, 0xa4, 0xd9, 0x7d,
	0x9f, 0x7a, 0x1f, 0x02, 0x66, 0x8c, 0x4a, 0x77, 0xa5, 0xe1, 0xb5, 0xc2, 0x2d, 0x60, 0x7f, 0x91,
	0xb3, 0x1f, 0x8f, 0x28, 0x73, 0x9f, 0xe2, 0x1b, 0xb1, 0xb4, 0x38, 0xa2, 0xcc, 0x16, 0x4b, 0x8b,
	0x23, 0xf9, 0x18, 0x06, 0x76, 0xc0, 0xec, 0x68, 0xda, 0xca, 0xde, 0x6e, 0xd3, 0xd9, 0x5a, 0x98,
	0x56, 0xde, 0xe8, 0x12, 0x06, 0x68, 0xdb, 0x65, 0x88, 0x45, 0x59, 0x54, 0xed, 0xeb, 0xd3, 0xca,
	0x20, 0x21, 0xf8, 0x3c, 0x63, 0x52, 0xf3, 0x04, 0x33, 0x71, 0x68, 0x63, 0x46, 0xbf, 0x39, 0x00,
	0xed, 0x90, 0xdf, 0xd7, 0x93, 0x3d, 0x96, 0x79, 0x47, 0x4f, 0xaa, 0xfa, 0x69, 0x43, 0x20, 0x53,
	0xf0, 0xaa, 0xa5, 0xc2, 0xc2, 0xee, 0x5a, 0xba, 0xda, 0xdf, 0x16, 0xe6, 0xfe, 0x6d, 0x61, 0xbf,
	0xf4, 0xc0, 0xab, 0xf2, 0xfb, 0xcf, 0x77, 0x01, 0x37, 0x49, 0x64, 0xf5, 0x59, 0xc0, 0x37, 0xf9,
	0x0c, 0xe0, 0xa4, 0x41, 0x73, 0x18, 0x1e, 0x9d, 0x4b, 0x3c, 0x5f, 0x35, 0x14, 0xda, 0x61, 0xdb,
	0x78, 0x4c, 0xeb, 0xf4, 0x50, 0xe4, 0xbc, 0x30, 0xa8, 0x47, 0x40, 0x3b, 0xc8, 0xbd, 0x97, 0xe1,
	0x74, 0x9f, 0xfc, 0xce, 0x7d, 0x7a, 0xf4, 0x14, 0x82, 0x55, 0x77, 0x1a, 0x6e, 0xb5, 0xfd, 0x02,
	0x06, 0x47, 0x96, 0x95, 0xd5, 0xec, 0xf4, 0x69, 0x65, 0x44, 0xcf, 0xc0, 0xa3, 0x5c, 0x97, 0x19,
	0x6a, 0xaa, 0xcb, 0x38, 0xe6, 0x5a, 0xe3, 0xcf, 0x86, 0xb4, 0x31, 0xdb, 0x80, 0xbd, 0x4e, 0xc0,
	0x28, 0x00, 0x7f, 0x9d, 0xad, 0x0b, 0x59, 0x9a, 0xe8, 0x5b, 0x18, 0xad, 0x4e, 0x79, 0xeb, 0xee,
	0xa9, 0x74, 0xfe, 0xe9, 0x54, 0xfe, 0xb5, 0x09, 0x70, 0xde, 0x84, 0xe8, 0x77, 0x07, 0xfc, 0x66,
	0xa1, 0x3f, 0x40, 0x81, 0xf6, 0x69, 0xc6, 0xbf, 0x3f, 0x09, 0x17, 0xd4, 0xc8, 0x3a, 0xb1, 0x6e,
	0x55, 0x31, 0xad, 0xbb, 0xde, 0x90, 0x1a, 0x59, 0x27, 0xe4, 0x23, 0x18, 0x59, 0x31, 0x85, 0x66,
	0x99, 0xf5, 0xf7, 0x5b, 0x7d, 0x2d, 0xb4, 0x4e, 0xc8, 0x7b, 0x10, 0x28, 0x6c, 0x85, 0x75, 0xbb,
	0xe8, 0x1e, 0x56, 0xc0, 0x3a, 0xb1, 0xdb, 0x67, 0xd2, 0x9c, 0x6b, 0xc3, 0x72, 0x89, 0x5a, 0xf5,
	0x69, 0x0b, 0x44, 0x6f, 0x20, 0x58, 0xa9, 0x43, 0x59, 0x95, 0xff, 0x18, 0xfc, 0x3a, 0x6a, 0x7d,
	0x73, 0x3a, 0xe7, 0xa3, 0x2e, 0x85, 0x36, 0x8c, 0xf3, 0x23, 0xd5, 0xfb, 0xb7, 0x47, 0xea, 0xf9,
	0xe5, 0x77, 0x4f, 0x0f, 0xa9, 0xb9, 0x2e, 0x77, 0xf3, 0x58, 0xe4, 0x8b, 0x17, 0x42, 0x1c, 0x32,
	0x7e, 0x95, 0x89, 0x32, 0xd9, 0x64, 0xcc, 0xec, 0x85, 0xca, 0x17, 0x42, 0xf2, 0xe2, 0x09, 0xfe,
	0x64, 0x91, 0x16, 0x86, 0xab, 0x82, 0x65, 0x0b, 0xb9, 0xdb, 0x79, 0xf8, 0x7f, 0xf9, 0xe9, 0x9f,
	0x01, 0x00, 0x00, 0xff, 0xff, 0x88, 0x40, 0x8a, 0x00, 0x53, 0x07, 0x00, 0x00,
}
